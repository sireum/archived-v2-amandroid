package org.sireum.amandroid.run.framework

import org.sireum.util._
import org.sireum.amandroid.Apk
import org.sireum.jawa.PrintReporter
import org.sireum.jawa.MsgLevel
import org.sireum.jawa.Global
import org.sireum.amandroid.AndroidGlobalConfig
import org.sireum.jawa.util.PerComponentTimer
import org.sireum.amandroid.decompile.ApkDecompiler
import org.sireum.amandroid.util.AndroidLibraryAPISummary
import org.sireum.jawa.Constants
import java.io.File
import org.sireum.jawa.JawaType
import java.util.regex.Pattern
import java.io.FileInputStream
import java.io.BufferedReader
import java.io.InputStreamReader
import org.sireum.jawa.Signature
import org.sireum.jawa.util.MyFileUtil
import java.io.PrintWriter
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.Success
import scala.util.Failure
import java.util.concurrent.TimeoutException
import scala.util.Try

object MalwareHiddenApiUsageStudy {
  
  object MalwareHiddenApiUsageStudyCounter {
    var total = 0
    var haveresult = 0
    override def toString: String = "Total:" + total + ", haveresult:" + haveresult + ", contains method invoke:" + apkHiddenApiMap.size
    
    def writeApiIntoFile(outputUri: FileResourceUri, fileName: String) = {
      val apiFile = FileUtil.toFile(MyFileUtil.appendFileName(outputUri, fileName))
      val out = new PrintWriter(apiFile)
      val hideApis: MMap[String, Int] = mmapEmpty
      val nonPublicApis: MMap[String, Int] = mmapEmpty
      apkHiddenApiMap.foreach {
        case (_, (hs, ns)) =>
          hs.foreach{
            h => 
              val hnum = hideApis.getOrElse(h, 0) + 1
              hideApis(h) = hnum
          }
          ns.foreach {
            n =>
              val nnum = nonPublicApis.getOrElse(n, 0) + 1
              nonPublicApis(n) = nnum
          }
      }
      out.println("Total app: " + haveresult)
      out.println("Hide Api List:")
      hideApis.toList.sortBy(a => a._1).foreach {
        case (api, num) =>
          out.println(api + " " + num)
      }
      out.println("Non Public Method List:")
      nonPublicApis.toList.sortBy(a => a._1).foreach {
        case (api, num) =>
          out.println(api + " " + num)
      }
      out.flush()
      out.close()
    }
    
    def writeApkApiIntoFile(outputUri: FileResourceUri, fileName: String) = {
      val apiFile = FileUtil.toFile(MyFileUtil.appendFileName(outputUri, fileName))
      val out = new PrintWriter(apiFile)
      val hideApis: MMap[String, Int] = mmapEmpty
      val nonPublicApis: MMap[String, Int] = mmapEmpty
      apkHiddenApiMap.foreach {
        case (_, (hs, ns)) =>
          hs.foreach{
            h => 
              val hnum = hideApis.getOrElse(h, 0) + 1
              hideApis(h) = hnum
          }
          ns.foreach {
            n =>
              val nnum = nonPublicApis.getOrElse(n, 0) + 1
              nonPublicApis(n) = nnum
          }
      }
      out.println("Total app: " + haveresult + ", contains method invoke: " + apkHiddenApiMap.size)
      apkHiddenApiMap.foreach {
        case (file, (hs, ns)) =>
          out.println("#####" + file + "#####")
          hs.foreach {
            h =>
              out.println("Invoke hide api: " + h)
          }
          ns.foreach {
            n =>
              out.println("Invoke non-public api: " + n)
          }
      }
      out.flush()
      out.close()
    }
  }
  
  val apkHiddenApiMap: MMap[FileResourceUri, (MSet[String], MSet[String])] = mmapEmpty
  
  val hiddenApiMap: MMap[String, (MSet[String], MSet[String])] = mmapEmpty
  
  def main(args: Array[String]): Unit = {
    val dir = args(0)
    val outPath = args(1)
    val filePath = args(2)
    val dirUri = FileUtil.toUri(dir)
    val outputUri = FileUtil.toUri(outPath)
    val fileUri = FileUtil.toUri(filePath)
    val fileHidein = new FileInputStream(FileUtil.toFile(fileUri + "/" + "HideApis.txt"))
    val hidebr = new BufferedReader(new InputStreamReader(fileHidein))
    var line = hidebr.readLine()
    while(line != null) {
      val sig = new Signature(line)
      val (hideApis, nonPublicMethods) = hiddenApiMap.getOrElseUpdate(sig.classTyp.name, (msetEmpty, msetEmpty))
      hideApis += sig.methodName
      line = hidebr.readLine()
    }
    hidebr.close()
    val fileNonPublicin = new FileInputStream(FileUtil.toFile(fileUri + "/" + "NonPublicMethods.txt"))
    val nonPublicbr = new BufferedReader(new InputStreamReader(fileNonPublicin))
    line = nonPublicbr.readLine()
    while(line != null) {
      val sig = new Signature(line)
      val (hideApis, nonPublicMethods) = hiddenApiMap.getOrElseUpdate(sig.classTyp.name, (msetEmpty, msetEmpty))
      nonPublicMethods += sig.methodName
      line = nonPublicbr.readLine()
    }
    nonPublicbr.close()
    val files = FileUtil.listFiles(dirUri, "", true)
    println("Total files: " + files.size)
    var i = 0
    var timeout = 0
    val futures: ISeq[Future[(FileResourceUri, Boolean)]] = files.map {
      fileUri =>
        val apkFile = FileUtil.toFile(fileUri)
        val resultDir = FileUtil.toFile(outputUri)
        val dirName = try{apkFile.getName().substring(0, apkFile.getName().lastIndexOf("."))} catch {case e: Exception => apkFile.getName()}
        val outDir = FileUtil.toFile(MyFileUtil.appendFileName(outputUri, dirName))
        val f = Future[Boolean] {
          try {
            var localI = 0
            this.synchronized{
              i += 1
              localI = i
            }
            if(localI % 10 == 0) println(localI)
            if(Apk.isValidApk(fileUri)) {
              ApkDecompiler.decompile(apkFile, resultDir, None, false, false, true, false)
              true
            } else false
          } catch {
            case e: InterruptedException =>
              false
          }
        }
        val af = Future((fileUri, Await.result(f, 30 minutes))).recover{
          case te: TimeoutException =>
            var localT = 0
            this.synchronized{
              timeout += 1
              localT = timeout
            }
            MyFileUtil.deleteDir(outDir)
            System.err.println(fileUri + " timeout! " + localT)
            (fileUri, false)
          case ex: Exception => 
            MyFileUtil.deleteDir(outDir)
            (fileUri, false)
        }
        af
    }
    val completedFiles: MSet[FileResourceUri] = msetEmpty
    val fseq = Future.sequence(futures)
    Await.result(fseq, Duration.Inf).foreach {
      case (fileUri, b) => if(b) completedFiles += fileUri
    }
    completedFiles foreach {
      fileUri =>
        MalwareHiddenApiUsageStudyCounter.total += 1
        println("#####" + fileUri + "#####")
        try {
          val reporter = new PrintReporter(MsgLevel.ERROR)
          val global = new Global(fileUri, reporter)
          global.setJavaLib(AndroidGlobalConfig.lib_files)
          val apk = new Apk(fileUri)
          val apkFile = FileUtil.toFile(fileUri)
          val resultDir = FileUtil.toFile(outputUri)
          val (outUri, srcs, _) = ApkDecompiler.decompile(apkFile, resultDir, None, false, false, true, false)
          // convert the dex file to the "pilar" form
          srcs foreach {
            src =>
              val fileUri = FileUtil.toUri(FileUtil.toFilePath(outUri) + File.separator + src)
              if(FileUtil.toFile(fileUri).exists()) {
                //store the app's pilar code in AmandroidCodeSource which is organized class by class.
                global.load(fileUri, Constants.PILAR_FILE_EXT, AndroidLibraryAPISummary)
              }
          }
          val stringPattern = Pattern.compile("\"([^\n]*)\"")
          val classPattern = Pattern.compile("constclass\\s@type\\s\\^`([^\n]*)`")
          global.getApplicationClassCodes foreach {
            case (typ, code) =>
              val strm = stringPattern.matcher(code.code)
              val strSet: MSet[String] = msetEmpty
              while(strm.find()) {
                strSet += strm.group(1)
              }
              val classm = classPattern.matcher(code.code)
              while(classm.find()) {
                strSet += classm.group(1)
              }
              val possibleMethodNames = strSet.filter(_.indexOf(".") < 0)
              strSet.filter(_.indexOf(".") > 0).foreach {
                name =>
                  hiddenApiMap.get(name) match {
                    case Some((h, n)) =>
                      possibleMethodNames.foreach {
                        mname =>
                          if(h.contains(mname)) {
                            println(typ + " have hide api: " + name + "." + mname)
                            val (hs, ns) = apkHiddenApiMap.getOrElseUpdate(fileUri, (msetEmpty, msetEmpty))
                            hs += name + "." + mname
                          }
                          if(n.contains(mname)) {
                            println(typ + " have non public api: " + name + "." + mname)
                            val (hs, ns) = apkHiddenApiMap.getOrElseUpdate(fileUri, (msetEmpty, msetEmpty))
                            ns += name + "." + mname
                          }
                      }
                    case None =>
                  }
              }
          }
          MalwareHiddenApiUsageStudyCounter.haveresult += 1
        } catch {
          case e: Exception =>
            System.err.println("Error: " + e.getMessage)
        } finally {
          println(MalwareHiddenApiUsageStudyCounter.toString())
          MalwareHiddenApiUsageStudyCounter.writeApiIntoFile(outputUri, "HiddenApiUsage.txt")
          MalwareHiddenApiUsageStudyCounter.writeApkApiIntoFile(outputUri, "ApkApiMap.txt")
        }
    }
  }
}
package org.sireum.amandroid.run.framework

import org.sireum.util._
import org.sireum.amandroid.Apk
import org.sireum.jawa.PrintReporter
import org.sireum.jawa.MsgLevel
import org.sireum.jawa.Global
import org.sireum.amandroid.AndroidGlobalConfig
import org.sireum.jawa.util.PerComponentTimer
import org.sireum.amandroid.decompile.ApkDecompiler
import org.sireum.amandroid.util.AndroidLibraryAPISummary
import org.sireum.jawa.Constants
import java.io.File
import org.sireum.jawa.JawaType
import java.util.regex.Pattern
import java.io.FileInputStream
import java.io.BufferedReader
import java.io.InputStreamReader
import org.sireum.jawa.Signature

/**
 * @author fgwei
 */
object MalwareHiddenApiUsageStudy {
  
  object MalwareHiddenApiUsageStudyCounter {
    var total = 0
    var haveresult = 0
    override def toString: String = "Total:" + total + ", haveresult:" + haveresult + ", contains method invoke:" + apkHiddenApiMap.size
  }
  
  val apkHiddenApiMap: MMap[FileResourceUri, MSet[JawaType]] = mmapEmpty
  
  val hiddenApiMap: MMap[String, (MSet[String], MSet[String])] = mmapEmpty
  
  def main(args: Array[String]): Unit = {
    val dir = args(0)
    val outPath = args(1)
    val filePath = args(2)
    val dirUri = FileUtil.toUri(dir)
    val outputUri = FileUtil.toUri(outPath)
    val fileUri = FileUtil.toUri(filePath)
    val fileHidein = new FileInputStream(FileUtil.toFile(fileUri + "/" + "HideApis.txt"))
    val hidebr = new BufferedReader(new InputStreamReader(fileHidein))
    var line = hidebr.readLine()
    while(line != null) {
      val sig = new Signature(line)
      val (hideApis, nonPublicMethods) = hiddenApiMap.getOrElseUpdate(sig.classTyp.name, (msetEmpty, msetEmpty))
      hideApis += sig.methodName
      line = hidebr.readLine()
    }
    hidebr.close()
    val fileNonPublicin = new FileInputStream(FileUtil.toFile(fileUri + "/" + "NonPublicMethods.txt"))
    val nonPublicbr = new BufferedReader(new InputStreamReader(fileNonPublicin))
    line = nonPublicbr.readLine()
    while(line != null) {
      val sig = new Signature(line)
      val (hideApis, nonPublicMethods) = hiddenApiMap.getOrElseUpdate(sig.classTyp.name, (msetEmpty, msetEmpty))
      nonPublicMethods += sig.methodName
      line = nonPublicbr.readLine()
    }
    nonPublicbr.close()
    FileUtil.listFiles(dirUri, "", true) foreach {
      fileUri =>
        if(Apk.isValidApk(fileUri)) {
          MalwareHiddenApiUsageStudyCounter.total += 1
          println("#####" + fileUri + "#####")
          try {
            val reporter = new PrintReporter(MsgLevel.ERROR)
            val global = new Global(fileUri, reporter)
            global.setJavaLib(AndroidGlobalConfig.lib_files)
            val apk = new Apk(fileUri)
            val apkFile = FileUtil.toFile(fileUri)
            val resultDir = FileUtil.toFile(outputUri)
            val (outUri, srcs, _) = ApkDecompiler.decompile(apkFile, resultDir, None, false, false, true, false)
            // convert the dex file to the "pilar" form
            srcs foreach {
              src =>
                val fileUri = FileUtil.toUri(FileUtil.toFilePath(outUri) + File.separator + src)
                if(FileUtil.toFile(fileUri).exists()) {
                  //store the app's pilar code in AmandroidCodeSource which is organized class by class.
                  global.load(fileUri, Constants.PILAR_FILE_EXT, AndroidLibraryAPISummary)
                }
            }
            val timer = new PerComponentTimer(600)
            timer.start
            val stringPattern = Pattern.compile("\"([^\n]*)\"")
            val classPattern = Pattern.compile("constclass\\s@type\\s\\^`([^\n]*)`")
            global.getApplicationClassCodes foreach {
              case (typ, code) =>
                val strm = stringPattern.matcher(code.code)
                val strSet: MSet[String] = msetEmpty
                while(strm.find()) {
                  strSet += strm.group(1)
                }
                val classm = classPattern.matcher(code.code)
                while(classm.find()) {
                  strSet += classm.group(1)
                }
                val possibleMethodNames = strSet.filter(_.indexOf(".") < 0)
                strSet.filter(_.indexOf(".") > 0).foreach {
                  name =>
                    hiddenApiMap.get(name) match {
                      case Some((h, n)) =>
                        possibleMethodNames.foreach {
                          mname =>
                            var find = false
                            if(h.contains(mname)) {
                              println(typ + " have hide api: " + name + "." + mname)
                              find = true
                            }
                            else if(n.contains(mname)) {
                              println(typ + " have non public api: " + name + "." + mname)
                              find = true
                            }
                            if(find) apkHiddenApiMap.getOrElseUpdate(fileUri, msetEmpty) += typ
                        }
                      case None =>
                    }
                }
            }
            MalwareHiddenApiUsageStudyCounter.haveresult += 1
          } catch {
            case e: Exception =>
              System.err.println("Error: " + e.getMessage)
          } finally {
            println(MalwareHiddenApiUsageStudyCounter.toString())
          }
        }
    }
  }
}